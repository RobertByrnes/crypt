<?php

 /**
 * @author Robert Byrnes
 * @created 27/01/2021
 **/

Class LockPick
{
    /**
     * string of characters used to test a hashed string against for md5 hashes.
     */
    private static string $charSet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

    /**
     * character set given by Samuel Morse (1791-1872) for interest!
     */
    private static string $morseChars = 'etaoinshrdlcumwfgypbvkxjqzETAOINSHRDLCUMWFGYPBVKXJQZ';

    /**
     * amount of allowable execution time in seconds for benchmarkServer().
     */
    private static int $serverTime;

    /**
     * the length of the string to test the hash against for md5 hashes.
     */
    private static int $charLen;

    /**
     * (float) stores startTime returned from startTimer().
     * @var float
     */
    private static $startTime = 0.0000;

    /**
     * (array) specifies the timezone and filepaths to logs and wordlists.
     *
     * @var array
     */
    private static $settings = array();


    /**
     * called from config.php in application root dir to initialise $settings array with
     * the timezone and filepaths to logs and wordlists.
     * @param array $settings
     * @return void
     */
    public static function init(array $settings) :void
	{
		self::$settings = $settings;
    }
    

    /**
    * microtime() function returns the current timestamp. This function is used to start the timer for calculating
    * the time required to brute force the password.
    * set_time_limit fuction is used to set the number of seconds a script is allowed to run.
    * @param integer $serverTime
    * @return void
    */
    public static function serverTime(int $time=NULL){
        $startTime = microtime(true);
        if ($time==NULL){
            self::$serverTime = 600;
        } else {
            self::$serverTime = $time;
        }
        set_time_limit($serverTime);
        return;
    }


    /**
     * define() function defines h_value constant with md5 hash of a password.
     * define() function defines $P_MAX_LEN constant with $p i.e. length of password entered,
     * which is the maximum length of a password to brute force.
     * strlen() function is used to find the length of the character set
     * @param string $md5
     * @return void
     */
    public static function handleMD5input(string $md5, string $string=NULL, int $time=NULL)
    {
        error_reporting(E_ALL & ~E_NOTICE);
        self::startTimer();
        if ($time==NULL){
            self::$serverTime = 600;
            set_time_limit(self::$serverTime);
        } else if ($time == 0) {
            set_time_limit(0);
        } else {
            self::$serverTime = $time;
            set_time_limit(self::$serverTime);
        }
        
        define('h_value', $md5);

        if($string != NULL) {
            $$P_MAX_LEN = strlen($string);
            self::$charLen = strlen(self::$charSet);
            self::repeat($P_MAX_LEN, 0, '');
        } else {
            for ($p=1; $p<15; $p++) { 
                self::$charLen = strlen(self::$charSet);
                self::repeat($p, 0, '');
            }
        }
        error_reporting(E_ALL);
    }


    public static function repeat($width, $position, $character) : void
    {                 
        for ($i = 0; $i < self::$charLen; $i++) 
        {        
            if ($position < $width - 1) {    
                self::repeat($width, $position + 1, $character . self::$charSet[$i]); 
            }      
            self::test($character . self::$charSet[$i]);    
        }
    } 


    /**
     * test() is used to check the md5 of password with the md5 of the string generated by repeat.
     * compares hash of password with the hash of words formed using repeat().
     * @param string $password
     * @return void
     */
    private static function test($password) : void
    {     
        if (hash('md5', $password) == h_value)
            {        
                echo '<b>'.$password.'</b>'; 
                $processTime = self::endTimer();
                echo '. Brute forcing this encryption took: '.$processTime.' seconds';
            exit;    
        }
        return;
    }


    /**
     * called from the constructor, begins a microsecond timer based on Unix Epoch time,
     * i.e. seconds since Unix Epoch on January 1st, 1970 at UTC.
     * @return float
     */
    private static function startTimer() : float
    {
        $mTime = microtime(); 
        $mTime = explode(" ",$mTime);
        $mTime = $mTime[1] + $mTime[0];
        self::$startTime = $mTime;
        return self::$startTime;
    }


    /**
     * ends timer started with call to startTimer() and returns execution time as a float,
     * if paramater $echo is passed as '1' will echo timer result.
     * @param boolean $echo
     * @return float
     */
    private static function endTimer($echo=NULL) : float
    {
        $mTime = microtime();
        $mTime = explode(" ",$mTime); 
        $mTime = $mTime[1] + $mTime[0]; 
        $endTime = $mTime; 
        $executionTime = number_format(($endTime - self::$startTime), 4);
        if($echo != NULL) {
            echo "This page was created in ".number_format($executionTime,4)." seconds"; 
        }
        return $executionTime;
    }

    
    /**
     * tests encrypted string against a library of strings for a match by encrypting the test string.
     * Warning: This could take considerable resources and time. To greatly reduce
     * processing time pass in min and max length of target string (if known).
     * @param string $hash
     * @return array
     */
    public static function verifyByComparison(string $hash, int $timelimit, int $minLen=NULL, int $maxLen=NULL) : array
    {
        if ($timelimit==NULL){
            self::$serverTime = 600;
            set_time_limit(self::$serverTime);
        } else if ($timelimit == 0) {
            set_time_limit(0);
        } else {
            self::$serverTime = $timelimit;
            set_time_limit(self::$serverTime);
        }

        self::init(array(
            'timezone'    => 'Europe/Amsterdam', // Time zone for the output file.
            'wordlist'    => 'C:\wamp64\www\repositories\crypt\wordlist\dictionary\dictionary_001.txt', // Path to the wordlist.
            'outputfile'  => '../logs/output.txt' // Output file where the matching combo('s) will be stored in.
        ));
     
        self::startTimer();

        foreach(self::scanLibrary() as $l => $testString) {
            if (password_verify($testString, $hash)) {
                $processTime = self::endTimer();
                $returnArray = array(
                    'testString' => $testString,
                    'processTime' => 'Resolving this encryption took '.$processTime.' seconds.'
                );
                return $returnArray;
            }
        }
        $fail = array(
            'message' => 'No match found.'
        );

        return $fail;
    }


    /**
     * scans a .txt file containing a list of possible password strings, the file
     * 'wordlist.txt' included with this application contain 1,000,000 entries.
     * To add a new/different list of strings, specify the filepath in config.php.
     * @return array
     */
    private static function scanLibrary() : array
    {
        if (!file_exists(self::$settings['wordlist'])) {
            trigger_error('File not found.'.self::$settings['wordlist']);
        } 
        else {
            $file = fopen(self::$settings['wordlist'], 'r');
            $file = fread($file, filesize(self::$settings['wordlist']));
            $file = str_replace(" ", "", $file);
            $file = str_replace("\r", "", $file);
            return preg_split("(\n)", $file );
        }
    }
   

    /**
     * writes output to log files specified in config.php.
     * @param string $data
     * @return boolean
     */
    private static function logAttack($data) : bool
	{
		if (!file_exists(self::$settings['outputfile']) ) {
			trigger_error('Output file doesn\'t exist');
		}

		date_default_timezone_set(self::$settings['timezone']);
		$date = date('m/d/Y h:i:s a', time());

        if (file_put_contents(self::$settings['outputfile'],"[{$date}] Server: " .  $data . "\n", FILE_APPEND)) {
            return true;
        }
        return false;
	}
}