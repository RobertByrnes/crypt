<?php

 /**
 * @author Robert Byrnes
 * @created 27/01/2021
 **/

// $name0 = $_POST['password']; /* get the value of a password sent using method="post" from the login form */
// $string = 'they';
// $md5 = md5($string); /*encryption scheme used to encrypt the password recieved using method="post"*/
// echo $md5;
// Cracker::handleMD5input($md5, $string, 2000);
// $testChars = 'abcde';
// $stringBruteTest = function ($testChars) {
// 	return strcmp(implode($testChars), "bbc") == 0;
// };

// $result = Cracker::stringBrute("abcde", 1, 5, $stringBruteTest);
// echo $result;
//stringBrute($testChars, $startLength, $endLength, $testCallback)



Class Cracker
{
    /**
     * string of characters used to test a hashed string against for md5 hashes.
     */
    private static string $charSet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

    /**
     * character set given by Samuel Morse (1791-1872) for interest!
     */
    private static string $morseChars = 'etaoinshrdlcumwfgypbvkxjqzETAOINSHRDLCUMWFGYPBVKXJQZ';

    /**
     * amount of allowable execution time in seconds for benchmarkServer().
     */
    private static int $serverTime;

    /**
     * the length of the string to test the hash against for md5 hashes.
     */
    private static int $charLen;

    /**
     * stores startTime returned from startTimer()
     * @var float
     */
    private static $startTime = 0.0000;

    /**
    * microtime() function returns the current timestamp. This function is used to start the timer for calculating
    * the time required to brute force the password.
    * set_time_limit fuction is used to set the number of seconds a script is allowed to run.
    * @param integer $serverTime
    * @return void
    */
    public static function serverTime(int $time=NULL){
        $startTime = microtime(true);
        if ($time==NULL){
            self::$serverTime = 600;
        } else {
            self::$serverTime = $time;
        }
        set_time_limit($serverTime);
        return;
    }

    /**
     * define() function defines h_value constant with md5 hash of a password.
     * define() function defines $P_MAX_LEN constant with $p i.e. length of password entered,
     * which is the maximum length of a password to brute force.
     * strlen() function is used to find the length of the character set
     * @param string $md5
     * @return void
     */
    public static function handleMD5input(string $md5, string $string=NULL, int $time=NULL)
    {
        error_reporting(E_ALL & ~E_NOTICE);
        self::startTimer();
        if ($time==NULL){
            self::$serverTime = 600;
        } else {
            self::$serverTime = $time;
        }
        set_time_limit(self::$serverTime);
        define('h_value', $md5);

        if($string != NULL) {
            $$P_MAX_LEN = strlen($string);
            self::$charLen = strlen(self::$charSet);
            self::repeat($P_MAX_LEN, 0, '');
        } else {
            for ($p=1; $p<15; $p++) { 
                self::$charLen = strlen(self::$charSet);
                self::repeat($p, 0, '');
            }
        }
        error_reporting(E_ALL);
    }


    public static function repeat($width, $position, $character) : void
    {                 
        for ($i = 0; $i < self::$charLen; $i++) 
        {        
            if ($position < $width - 1) {    
                self::repeat($width, $position + 1, $character . self::$charSet[$i]); 
            }      
            self::test($character . self::$charSet[$i]);    
        }
    } 


    /**
     * test() is used to check the md5 of password with the md5 of the string generated by repeat.
     * compares hash of password with the hash of words formed using repeat().
     * @param string $password
     * @return void
     */
    private static function test($password) : void
    {     
        if (hash('md5', $password) == h_value)
            {        
                echo '<br/><br/>'.'Match found: '.$password."\r\n"; 
                $processTime = self::endTimer();
                echo '<br/></br>'.'Cracking this encryption took: '.$processTime.' seconds';
            exit;    
        }
        return;
    }


    /**
     * called from the constructor, begins a microsecond timer based on Unix Epoch time,
     * i.e. seconds since Unix Epoch on January 1st, 1970 at UTC.
     * @return float
     */
    private static function startTimer() : float
    {
        $mTime = microtime(); 
        $mTime = explode(" ",$mTime);
        $mTime = $mTime[1] + $mTime[0];
        self::$startTime = $mTime;
        return self::$startTime;
    }


    /**
     * ends timer started with call to startTimer() and returns execution time as a float,
     * if paramater $echo is passed as '1' will echo timer result.
     * @param boolean $echo
     * @return float
     */
    private static function endTimer($echo=NULL) : float
    {
        $mTime = microtime();
        $mTime = explode(" ",$mTime); 
        $mTime = $mTime[1] + $mTime[0]; 
        $endTime = $mTime; 
        $executionTime = number_format(($endTime - self::$startTime), 4);
        if($echo != NULL) {
            echo "This page was created in ".number_format($executionTime,4)." seconds"; 
        }
        return $executionTime;
    }


    
    
}