<?php

 /**
 * @author Robert Byrnes
 * @created 27/01/2021
 **/

// $name0 = $_POST['password']; /* get the value of a password sent using method="post" from the login form */
// $string = 'they';
// $md5 = md5($string); /*encryption scheme used to encrypt the password recieved using method="post"*/
// echo $md5;
// Cracker::handleMD5input($md5, $string, 2000);
$testChars = 'abcde';
$BruteForceTest = function ($testChars) {
	return strcmp(implode($testChars), "bbc") == 0;
};

$result = Cracker::bruteForce("abcde", 1, 5, $BruteForceTest);
echo $result;
//bruteForce($testChars, $startLength, $endLength, $testCallback)



Class Cracker
{
    /**
     * character set which is used to brute force the password.
     */
    private static string $charSet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

    /**
     * character set given by Samuel Morse (1791-1872).
     */
    private static string $morseChars = 'etaoinshrdlcumwfgypbvkxjqzETAOINSHRDLCUMWFGYPBVKXJQZ';

    /**
     * amount of allowable execution time in seconds.
     */
    private static int $serverTime;

    private static $charLen;

    /**
    * microtime() function returns the current timestamp. This function is used to start the timer for calculating
    * the time required to brute force the password.
    * set_time_limit fuction is used to set the number of seconds a script is allowed to run.
    * @param integer $serverTime
    * @return void
    */
    public static function serverTime(int $time=NULL){
        $startTime = microtime(true);
        if ($time==NULL){
            self::$serverTime = 600;
        } else {
            self::$serverTime = $time;
        }
        set_time_limit($serverTime);
        return;
    }

    /**
     * define() function defines h_value constant with md5 hash of a password.
     * define() function defines P_MAX_LEN constant with $p i.e. length of password entered,
     * which is the maximum length of a password to brute force.
     * strlen() function is used to find the length of the character set
     * @param string $md5
     * @return void
     */
    public static function handleMD5input(string $md5, string $string, int $time=NULL)
    {
        $startTime = microtime(true);
        if ($time==NULL){
            self::$serverTime = 600;
        } else {
            self::$serverTime = $time;
        }
        set_time_limit(self::$serverTime);
        define('h_value', $md5);
        $p = strlen($string);
        define('P_MAX_LEN', $p);
        self::$charLen = strlen(self::$charSet);
        self::repeat(P_MAX_LEN, 0, '');
    }


    public static function repeat($width, $position, $character)
    {                 
        for ($i = 0; $i < self::$charLen; $i++) 
        {        
            if ($position < $width - 1) {    
                self::repeat($width, $position + 1, $character . self::$charSet[$i]); 
            }      
            self::test($character . self::$charSet[$i]);    
        }
    } 


    /**
     * test() is used to check the md5 of password with the md5 of the string generated by repeat.
     * compares hash of password with the hash of words formed using repeat().
     * @param [type] $password
     * @return void
     */
    public static function test($password)
    {     
        global $startTime;
        if (hash('md5', $password) == h_value)
            {        
                echo '<br/><br/>'.'FOUND MATCH, password: '.$password."\r\n";  
                $stopTime = microtime(true);	 /*$stopTime variable stores the time when the execution ends*/
                $processTime = $stopTime-$startTime; 	/*$processTime variable stores the time taken for processing*/  
                echo '<br/></br>'.'time taken for processing is '.round($processTime).' seconds';
            exit;    
        }
    }
    
    public static function bruteForce($testChars, $startLength, $endLength, $testCallback)
    {
        for ($len = $startLength; $len <= $endLength; ++$len)
        {
            $chars = array();

            for ($i = 0; $i < $len; ++$i)
                $chars[$i] = $testChars[0];

            if ($testCallback($chars))
                return true;

            for ($i1 = $len - 1; $i1 > -1; --$i1)
            {
                $i2 = 0;
                $testCharsLen = strlen($testChars);
                
                for ($i2 = strpos($testChars, $chars[$i1]) + 1; $i2 < $testCharsLen; ++$i2)
                {
                    $chars[$i1] = $testChars[$i2];

                    if ($testCallback($chars))
                        return true;

                    for ($i3 = $i1 + 1; $i3 < $len; ++$i3)
                    {
                        if ($chars[$i3] != $testChars[$testCharsLen - 1])
                        {
                            $i1 = $len;
                            goto outerBreak;
                        }
                    }
                }

                outerBreak:
                if ($i2 == $testCharsLen)
                    $chars[$i1] = $testChars[0];
            }
        }

        return false;
    }
}